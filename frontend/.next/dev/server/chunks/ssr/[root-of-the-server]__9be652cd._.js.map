{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/lib/generated/prisma/internal/class.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * Please import the `PrismaClient` class from the `client.ts` file instead.\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"./prismaNamespace\"\n\n\nconst config: runtime.GetPrismaClientConfig = {\n  \"previewFeatures\": [],\n  \"clientVersion\": \"7.0.0\",\n  \"engineVersion\": \"0c19ccc313cf9911a90d99d2ac2eb0280c76c513\",\n  \"activeProvider\": \"postgresql\",\n  \"inlineSchema\": \"// This is your Prisma schema file,\\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\\n\\n// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?\\n// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init\\n\\ngenerator client {\\n  provider = \\\"prisma-client\\\"\\n  output   = \\\"../lib/generated/prisma\\\"\\n}\\n\\ndatasource db {\\n  provider = \\\"postgresql\\\"\\n}\\n\\nenum Role {\\n  ADMIN\\n  ANALYST\\n  OFFICER\\n  GUEST\\n}\\n\\nenum AccType {\\n  SAVINGS\\n  CURRENT\\n  SALARY\\n}\\n\\nenum AccStatus {\\n  ACTIVE\\n  DORMANT\\n  FROZEN\\n  CLOSED\\n}\\n\\nenum TxType {\\n  CREDIT\\n  DEBIT\\n  TRANSFER\\n  UPI\\n}\\n\\nenum Status {\\n  PENDING\\n  COMPLETED\\n  FAILED\\n}\\n\\nmodel User {\\n  id         Int      @id @default(autoincrement())\\n  firstName  String\\n  lastName   String\\n  city       String?\\n  phone      String   @unique\\n  dob        String\\n  email      String   @unique\\n  password   String\\n  role       Role     @default(GUEST)\\n  createdAt  DateTime @default(now())\\n  uppdatedAt DateTime @updatedAt\\n}\\n\\nmodel Branch {\\n  id       String    @id @default(uuid())\\n  code     String\\n  name     String\\n  city     String\\n  // relations\\n  accounts Account[]\\n}\\n\\nmodel Account {\\n  id          String    @id @default(uuid())\\n  account_no  String    @unique\\n  type        AccType\\n  status      AccStatus @default(ACTIVE)\\n  openingDate DateTime?\\n  closingDate DateTime?\\n\\n  // relations\\n  customer   Customer @relation(fields: [customerId], references: [id])\\n  customerId String\\n  branch     Branch   @relation(fields: [branchId], references: [id])\\n  branchId   String\\n\\n  benefactorTransactions  Transaction[] @relation(\\\"benefactorAccount\\\")\\n  beneficiaryTransactions Transaction[] @relation(\\\"beneficiaryAccount\\\")\\n}\\n\\nmodel Customer {\\n  id        String   @id @default(uuid())\\n  name      String\\n  email     String   @unique\\n  phone     String?  @unique\\n  createdAt DateTime @default(now())\\n\\n  // relations\\n  accounts Account[]\\n}\\n\\n// model Transaction {\\n//   id          String   @id @default(uuid())\\n//   date        DateTime @default(now())\\n//   benefactor  String\\n//   beneficiary String\\n//   status      Status\\n//   type        TxType\\n//   risk_score  Int\\n//   amount      Float\\n//   currency    String?  @default(\\\"INR\\\")\\n//   description String?\\n//   reference   String?  @unique\\n\\n//   benefactorCustomer  Customer @relation(\\\"benefactor\\\", fields: [benefactor], references: [id])\\n//   beneficiaryCustomer Customer @relation(\\\"beneficiary\\\", fields: [beneficiary], references: [id])\\n\\n//   @@index([benefactor])\\n//   @@index([beneficiary])\\n// }\\n\\nmodel Transaction {\\n  id   String   @id @default(uuid())\\n  date DateTime @default(now())\\n\\n  // Prefer referencing accounts. If external counterparty, beneficiaryAccountId or benefactorAccountId can be null\\n  benefactorAccountId  String? // internal account id (nullable for external)\\n  beneficiaryAccountId String? // internal account id (nullable for external)\\n\\n  // For external transfers (other banks), store the external account number here.\\n  benefactor_account_no  String? // optional string for external sender account number\\n  beneficiary_account_no String? // optional string for external receiver account number\\n\\n  status      Status\\n  type        TxType\\n  risk_score  Int\\n  amount      Float\\n  currency    String? @default(\\\"INR\\\")\\n  description String?\\n  reference   String? @unique\\n\\n  // relations to internal accounts (if present)\\n  benefactorAccount  Account? @relation(\\\"benefactorAccount\\\", fields: [benefactorAccountId], references: [id])\\n  beneficiaryAccount Account? @relation(\\\"beneficiaryAccount\\\", fields: [beneficiaryAccountId], references: [id])\\n\\n  @@index([benefactorAccountId])\\n  @@index([beneficiaryAccountId])\\n}\\n\",\n  \"runtimeDataModel\": {\n    \"models\": {},\n    \"enums\": {},\n    \"types\": {}\n  }\n}\n\nconfig.runtimeDataModel = JSON.parse(\"{\\\"models\\\":{\\\"User\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"firstName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"lastName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"city\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"phone\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"dob\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"email\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"password\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"role\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"Role\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"uppdatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"Branch\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"code\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"city\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"accounts\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Account\\\",\\\"relationName\\\":\\\"AccountToBranch\\\"}],\\\"dbName\\\":null},\\\"Account\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"account_no\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"type\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"AccType\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"AccStatus\\\"},{\\\"name\\\":\\\"openingDate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"closingDate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"customer\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Customer\\\",\\\"relationName\\\":\\\"AccountToCustomer\\\"},{\\\"name\\\":\\\"customerId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"branch\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Branch\\\",\\\"relationName\\\":\\\"AccountToBranch\\\"},{\\\"name\\\":\\\"branchId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"benefactorTransactions\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Transaction\\\",\\\"relationName\\\":\\\"benefactorAccount\\\"},{\\\"name\\\":\\\"beneficiaryTransactions\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Transaction\\\",\\\"relationName\\\":\\\"beneficiaryAccount\\\"}],\\\"dbName\\\":null},\\\"Customer\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"email\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"phone\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"accounts\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Account\\\",\\\"relationName\\\":\\\"AccountToCustomer\\\"}],\\\"dbName\\\":null},\\\"Transaction\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"date\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"benefactorAccountId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"beneficiaryAccountId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"benefactor_account_no\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"beneficiary_account_no\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"Status\\\"},{\\\"name\\\":\\\"type\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"TxType\\\"},{\\\"name\\\":\\\"risk_score\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"amount\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"currency\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"description\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"reference\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"benefactorAccount\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Account\\\",\\\"relationName\\\":\\\"benefactorAccount\\\"},{\\\"name\\\":\\\"beneficiaryAccount\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Account\\\",\\\"relationName\\\":\\\"beneficiaryAccount\\\"}],\\\"dbName\\\":null}},\\\"enums\\\":{},\\\"types\\\":{}}\")\n\nasync function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {\n  const { Buffer } = await import('node:buffer')\n  const wasmArray = Buffer.from(wasmBase64, 'base64')\n  return new WebAssembly.Module(wasmArray)\n}\n\nconfig.compilerWasm = {\n  getRuntime: async () => await import(\"@prisma/client/runtime/query_compiler_bg.postgresql.js\"),\n\n  getQueryCompilerWasmModule: async () => {\n    const { wasm } = await import(\"@prisma/client/runtime/query_compiler_bg.postgresql.wasm-base64.js\")\n    return await decodeBase64AsWasm(wasm)\n  }\n}\n\n\n\nexport type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =\n  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never\n\nexport interface PrismaClientConstructor {\n    /**\n   * ## Prisma Client\n   * \n   * Type-safe database client for TypeScript\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Users\n   * const users = await prisma.user.findMany()\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  new <\n    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n    LogOpts extends LogOptions<Options> = LogOptions<Options>,\n    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],\n    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>\n}\n\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.user.findMany()\n * ```\n * \n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\n\nexport interface PrismaClient<\n  in LogOpts extends Prisma.LogLevel = never,\n  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,\n  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): runtime.Types.Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): runtime.Types.Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>\n\n  $extends: runtime.Types.Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.user`: Exposes CRUD operations for the **User** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Users\n    * const users = await prisma.user.findMany()\n    * ```\n    */\n  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Branches\n    * const branches = await prisma.branch.findMany()\n    * ```\n    */\n  get branch(): Prisma.BranchDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.account`: Exposes CRUD operations for the **Account** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Accounts\n    * const accounts = await prisma.account.findMany()\n    * ```\n    */\n  get account(): Prisma.AccountDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Customers\n    * const customers = await prisma.customer.findMany()\n    * ```\n    */\n  get customer(): Prisma.CustomerDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Transactions\n    * const transactions = await prisma.transaction.findMany()\n    * ```\n    */\n  get transaction(): Prisma.TransactionDelegate<ExtArgs, { omit: OmitOpts }>;\n}\n\nexport function getPrismaClientClass(): PrismaClientConstructor {\n  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor\n}\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;CAMC;;;;AAED;;;;;;AAIA,MAAM,SAAwC;IAC5C,mBAAmB,EAAE;IACrB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;QAClB,UAAU,CAAC;QACX,SAAS,CAAC;QACV,SAAS,CAAC;IACZ;AACF;AAEA,OAAO,gBAAgB,GAAG,KAAK,KAAK,CAAC;AAErC,eAAe,mBAAmB,UAAkB;IAClD,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,MAAM,YAAY,OAAO,IAAI,CAAC,YAAY;IAC1C,OAAO,IAAI,YAAY,MAAM,CAAC;AAChC;AAEA,OAAO,YAAY,GAAG;IACpB,YAAY,UAAY;IAExB,4BAA4B;QAC1B,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,OAAO,MAAM,mBAAmB;IAClC;AACF;AAsLO,SAAS;IACd,OAAO,iMAAuB,CAAC;AACjC","debugId":null}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/lib/generated/prisma/internal/prismaNamespace.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.0.0\n * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.0.0\",\n  engine: \"0c19ccc313cf9911a90d99d2ac2eb0280c76c513\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  User: 'User',\n  Branch: 'Branch',\n  Account: 'Account',\n  Customer: 'Customer',\n  Transaction: 'Transaction'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"user\" | \"branch\" | \"account\" | \"customer\" | \"transaction\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    User: {\n      payload: Prisma.$UserPayload<ExtArgs>\n      fields: Prisma.UserFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.UserFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findFirst: {\n          args: Prisma.UserFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findMany: {\n          args: Prisma.UserFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        create: {\n          args: Prisma.UserCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        createMany: {\n          args: Prisma.UserCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        delete: {\n          args: Prisma.UserDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        update: {\n          args: Prisma.UserUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        deleteMany: {\n          args: Prisma.UserDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.UserUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        upsert: {\n          args: Prisma.UserUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        aggregate: {\n          args: Prisma.UserAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>\n        }\n        groupBy: {\n          args: Prisma.UserGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.UserCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number\n        }\n      }\n    }\n    Branch: {\n      payload: Prisma.$BranchPayload<ExtArgs>\n      fields: Prisma.BranchFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.BranchFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>\n        }\n        findFirst: {\n          args: Prisma.BranchFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>\n        }\n        findMany: {\n          args: Prisma.BranchFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>[]\n        }\n        create: {\n          args: Prisma.BranchCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>\n        }\n        createMany: {\n          args: Prisma.BranchCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>[]\n        }\n        delete: {\n          args: Prisma.BranchDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>\n        }\n        update: {\n          args: Prisma.BranchUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>\n        }\n        deleteMany: {\n          args: Prisma.BranchDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.BranchUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>[]\n        }\n        upsert: {\n          args: Prisma.BranchUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>\n        }\n        aggregate: {\n          args: Prisma.BranchAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateBranch>\n        }\n        groupBy: {\n          args: Prisma.BranchGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.BranchGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.BranchCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.BranchCountAggregateOutputType> | number\n        }\n      }\n    }\n    Account: {\n      payload: Prisma.$AccountPayload<ExtArgs>\n      fields: Prisma.AccountFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.AccountFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>\n        }\n        findFirst: {\n          args: Prisma.AccountFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>\n        }\n        findMany: {\n          args: Prisma.AccountFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]\n        }\n        create: {\n          args: Prisma.AccountCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>\n        }\n        createMany: {\n          args: Prisma.AccountCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]\n        }\n        delete: {\n          args: Prisma.AccountDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>\n        }\n        update: {\n          args: Prisma.AccountUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>\n        }\n        deleteMany: {\n          args: Prisma.AccountDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.AccountUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]\n        }\n        upsert: {\n          args: Prisma.AccountUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>\n        }\n        aggregate: {\n          args: Prisma.AccountAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>\n        }\n        groupBy: {\n          args: Prisma.AccountGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.AccountCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number\n        }\n      }\n    }\n    Customer: {\n      payload: Prisma.$CustomerPayload<ExtArgs>\n      fields: Prisma.CustomerFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.CustomerFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>\n        }\n        findFirst: {\n          args: Prisma.CustomerFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>\n        }\n        findMany: {\n          args: Prisma.CustomerFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]\n        }\n        create: {\n          args: Prisma.CustomerCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>\n        }\n        createMany: {\n          args: Prisma.CustomerCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]\n        }\n        delete: {\n          args: Prisma.CustomerDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>\n        }\n        update: {\n          args: Prisma.CustomerUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>\n        }\n        deleteMany: {\n          args: Prisma.CustomerDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.CustomerUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]\n        }\n        upsert: {\n          args: Prisma.CustomerUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>\n        }\n        aggregate: {\n          args: Prisma.CustomerAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>\n        }\n        groupBy: {\n          args: Prisma.CustomerGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.CustomerCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number\n        }\n      }\n    }\n    Transaction: {\n      payload: Prisma.$TransactionPayload<ExtArgs>\n      fields: Prisma.TransactionFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.TransactionFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>\n        }\n        findFirst: {\n          args: Prisma.TransactionFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>\n        }\n        findMany: {\n          args: Prisma.TransactionFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]\n        }\n        create: {\n          args: Prisma.TransactionCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>\n        }\n        createMany: {\n          args: Prisma.TransactionCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]\n        }\n        delete: {\n          args: Prisma.TransactionDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>\n        }\n        update: {\n          args: Prisma.TransactionUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>\n        }\n        deleteMany: {\n          args: Prisma.TransactionDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.TransactionUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]\n        }\n        upsert: {\n          args: Prisma.TransactionUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>\n        }\n        aggregate: {\n          args: Prisma.TransactionAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>\n        }\n        groupBy: {\n          args: Prisma.TransactionGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.TransactionCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  ReadUncommitted: 'ReadUncommitted',\n  ReadCommitted: 'ReadCommitted',\n  RepeatableRead: 'RepeatableRead',\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const UserScalarFieldEnum = {\n  id: 'id',\n  firstName: 'firstName',\n  lastName: 'lastName',\n  city: 'city',\n  phone: 'phone',\n  dob: 'dob',\n  email: 'email',\n  password: 'password',\n  role: 'role',\n  createdAt: 'createdAt',\n  uppdatedAt: 'uppdatedAt'\n} as const\n\nexport type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]\n\n\nexport const BranchScalarFieldEnum = {\n  id: 'id',\n  code: 'code',\n  name: 'name',\n  city: 'city'\n} as const\n\nexport type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]\n\n\nexport const AccountScalarFieldEnum = {\n  id: 'id',\n  account_no: 'account_no',\n  type: 'type',\n  status: 'status',\n  openingDate: 'openingDate',\n  closingDate: 'closingDate',\n  customerId: 'customerId',\n  branchId: 'branchId'\n} as const\n\nexport type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]\n\n\nexport const CustomerScalarFieldEnum = {\n  id: 'id',\n  name: 'name',\n  email: 'email',\n  phone: 'phone',\n  createdAt: 'createdAt'\n} as const\n\nexport type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]\n\n\nexport const TransactionScalarFieldEnum = {\n  id: 'id',\n  date: 'date',\n  benefactorAccountId: 'benefactorAccountId',\n  beneficiaryAccountId: 'beneficiaryAccountId',\n  benefactor_account_no: 'benefactor_account_no',\n  beneficiary_account_no: 'beneficiary_account_no',\n  status: 'status',\n  type: 'type',\n  risk_score: 'risk_score',\n  amount: 'amount',\n  currency: 'currency',\n  description: 'description',\n  reference: 'reference'\n} as const\n\nexport type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const QueryMode = {\n  default: 'default',\n  insensitive: 'insensitive'\n} as const\n\nexport type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n/**\n * Reference to a field of type 'Int[]'\n */\nexport type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'String[]'\n */\nexport type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n/**\n * Reference to a field of type 'Role'\n */\nexport type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>\n    \n\n\n/**\n * Reference to a field of type 'Role[]'\n */\nexport type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime[]'\n */\nexport type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n/**\n * Reference to a field of type 'AccType'\n */\nexport type EnumAccTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccType'>\n    \n\n\n/**\n * Reference to a field of type 'AccType[]'\n */\nexport type ListEnumAccTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccType[]'>\n    \n\n\n/**\n * Reference to a field of type 'AccStatus'\n */\nexport type EnumAccStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccStatus'>\n    \n\n\n/**\n * Reference to a field of type 'AccStatus[]'\n */\nexport type ListEnumAccStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccStatus[]'>\n    \n\n\n/**\n * Reference to a field of type 'Status'\n */\nexport type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>\n    \n\n\n/**\n * Reference to a field of type 'Status[]'\n */\nexport type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>\n    \n\n\n/**\n * Reference to a field of type 'TxType'\n */\nexport type EnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType'>\n    \n\n\n/**\n * Reference to a field of type 'TxType[]'\n */\nexport type ListEnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType[]'>\n    \n\n\n/**\n * Reference to a field of type 'Float'\n */\nexport type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n/**\n * Reference to a field of type 'Float[]'\n */\nexport type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n}\nexport type GlobalOmitConfig = {\n  user?: Prisma.UserOmit\n  branch?: Prisma.BranchOmit\n  account?: Prisma.AccountOmit\n  customer?: Prisma.CustomerOmit\n  transaction?: Prisma.TransactionOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;;;;;CAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAED;;;;;;AAcO,MAAM,gCAAgC,+MAAqC;AAG3E,MAAM,kCAAkC,iNAAuC;AAG/E,MAAM,6BAA6B,4MAAkC;AAGrE,MAAM,kCAAkC,iNAAuC;AAG/E,MAAM,8BAA8B,6MAAmC;AAMvE,MAAM,MAAM,wLAAc;AAC1B,MAAM,QAAQ,uLAAa;AAC3B,MAAM,OAAO,sLAAY;AACzB,MAAM,MAAM,qLAAW;AACvB,MAAM,MAAM,qLAAW;AAQvB,MAAM,UAAU,yLAAe;AAS/B,MAAM,sBAAsB,4LAAkB,CAAC,mBAAmB;AAelE,MAAM,gBAA+B;IAC1C,QAAQ;IACR,QAAQ;AACV;AAeO,MAAM,YAAY;IACvB,QAAQ,2LAAiB,CAAC,MAAM;IAChC,UAAU,2LAAiB,CAAC,QAAQ;IACpC,SAAS,2LAAiB,CAAC,OAAO;AACpC;AAMO,MAAM,SAAS,wLAAc;AAO7B,MAAM,WAAW,0LAAgB;AAOjC,MAAM,UAAU,yLAAe;AAkQ/B,MAAM,YAAY;IACvB,MAAM;IACN,QAAQ;IACR,SAAS;IACT,UAAU;IACV,aAAa;AACf;AAkaO,MAAM,4BAA4B,gMAAsB,CAAC;IAC9D,iBAAiB;IACjB,eAAe;IACf,gBAAgB;IAChB,cAAc;AAChB;AAKO,MAAM,sBAAsB;IACjC,IAAI;IACJ,WAAW;IACX,UAAU;IACV,MAAM;IACN,OAAO;IACP,KAAK;IACL,OAAO;IACP,UAAU;IACV,MAAM;IACN,WAAW;IACX,YAAY;AACd;AAKO,MAAM,wBAAwB;IACnC,IAAI;IACJ,MAAM;IACN,MAAM;IACN,MAAM;AACR;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,YAAY;IACZ,MAAM;IACN,QAAQ;IACR,aAAa;IACb,aAAa;IACb,YAAY;IACZ,UAAU;AACZ;AAKO,MAAM,0BAA0B;IACrC,IAAI;IACJ,MAAM;IACN,OAAO;IACP,OAAO;IACP,WAAW;AACb;AAKO,MAAM,6BAA6B;IACxC,IAAI;IACJ,MAAM;IACN,qBAAqB;IACrB,sBAAsB;IACtB,uBAAuB;IACvB,wBAAwB;IACxB,QAAQ;IACR,MAAM;IACN,YAAY;IACZ,QAAQ;IACR,UAAU;IACV,aAAa;IACb,WAAW;AACb;AAKO,MAAM,YAAY;IACvB,KAAK;IACL,MAAM;AACR;AAKO,MAAM,YAAY;IACvB,SAAS;IACT,aAAa;AACf;AAKO,MAAM,aAAa;IACxB,OAAO;IACP,MAAM;AACR;AA+IO,MAAM,kBAAkB,4LAAkB,CAAC,eAAe","debugId":null}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/lib/generated/prisma/enums.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n* This file exports all enum related types from the schema.\n*\n* ðŸŸ¢ You can import this file directly.\n*/\n\nexport const Role = {\n  ADMIN: 'ADMIN',\n  ANALYST: 'ANALYST',\n  OFFICER: 'OFFICER',\n  GUEST: 'GUEST'\n} as const\n\nexport type Role = (typeof Role)[keyof typeof Role]\n\n\nexport const AccType = {\n  SAVINGS: 'SAVINGS',\n  CURRENT: 'CURRENT',\n  SALARY: 'SALARY'\n} as const\n\nexport type AccType = (typeof AccType)[keyof typeof AccType]\n\n\nexport const AccStatus = {\n  ACTIVE: 'ACTIVE',\n  DORMANT: 'DORMANT',\n  FROZEN: 'FROZEN',\n  CLOSED: 'CLOSED'\n} as const\n\nexport type AccStatus = (typeof AccStatus)[keyof typeof AccStatus]\n\n\nexport const TxType = {\n  CREDIT: 'CREDIT',\n  DEBIT: 'DEBIT',\n  TRANSFER: 'TRANSFER',\n  UPI: 'UPI'\n} as const\n\nexport type TxType = (typeof TxType)[keyof typeof TxType]\n\n\nexport const Status = {\n  PENDING: 'PENDING',\n  COMPLETED: 'COMPLETED',\n  FAILED: 'FAILED'\n} as const\n\nexport type Status = (typeof Status)[keyof typeof Status]\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;AAIA;;;;;;;;;;;;AAEO,MAAM,OAAO;IAClB,OAAO;IACP,SAAS;IACT,SAAS;IACT,OAAO;AACT;AAKO,MAAM,UAAU;IACrB,SAAS;IACT,SAAS;IACT,QAAQ;AACV;AAKO,MAAM,YAAY;IACvB,QAAQ;IACR,SAAS;IACT,QAAQ;IACR,QAAQ;AACV;AAKO,MAAM,SAAS;IACpB,QAAQ;IACR,OAAO;IACP,UAAU;IACV,KAAK;AACP;AAKO,MAAM,SAAS;IACpB,SAAS;IACT,WAAW;IACX,QAAQ;AACV","debugId":null}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/lib/generated/prisma/client.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.\n * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.\n *\n * ðŸŸ¢ You can import this file directly.\n */\n\nimport * as process from 'node:process'\nimport * as path from 'node:path'\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport * as $Enums from \"./enums\"\nimport * as $Class from \"./internal/class\"\nimport * as Prisma from \"./internal/prismaNamespace\"\n\nexport * as $Enums from './enums'\nexport * from \"./enums\"\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.user.findMany()\n * ```\n * \n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport const PrismaClient = $Class.getPrismaClientClass()\nexport type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions[\"omit\"] = Prisma.PrismaClientOptions[\"omit\"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>\nexport { Prisma }\n\n/**\n * Model User\n * \n */\nexport type User = Prisma.UserModel\n/**\n * Model Branch\n * \n */\nexport type Branch = Prisma.BranchModel\n/**\n * Model Account\n * \n */\nexport type Account = Prisma.AccountModel\n/**\n * Model Customer\n * \n */\nexport type Customer = Prisma.CustomerModel\n/**\n * Model Transaction\n * \n */\nexport type Transaction = Prisma.TransactionModel\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;CAKC;;;;AAOD;AACA;AAEA;;;;;;;;;;AAeO,MAAM,eAAe,kMAA2B","debugId":null}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/lib/db.ts"],"sourcesContent":["// src/lib/prismadb.ts\r\nimport { PrismaClient } from \"../lib/generated/prisma/client\";\r\n\r\nconst prismaClientSingleton = () => {\r\n  return new PrismaClient({});\r\n};\r\n\r\ndeclare const globalThis: {\r\n  prismaGlobal: ReturnType<typeof prismaClientSingleton>;\r\n} & typeof global;\r\n\r\nconst prisma = globalThis.prismaGlobal ?? prismaClientSingleton();\r\n\r\nexport default prisma;\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalThis.prismaGlobal = prisma;\r\n"],"names":[],"mappings":"AAAA,sBAAsB;;;;;AACtB;;;;;;AAEA,MAAM,wBAAwB;IAC5B,OAAO,IAAI,+LAAY,CAAC,CAAC;AAC3B;AAMA,MAAM,SAAS,WAAW,YAAY,IAAI;uCAE3B;AAEf,wCAA2C,WAAW,YAAY,GAAG","debugId":null}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/components/HeaderBox.tsx"],"sourcesContent":["const HeaderBox = ({\r\n  type = \"title\",\r\n  title,\r\n  subtext,\r\n  user,\r\n}: HeaderBoxProps) => {\r\n  return (\r\n    <div className=\"header-box\">\r\n      <h1 className=\"header-box-title\">\r\n        {title}\r\n        {type === \"greeting\" && (\r\n          <span className=\"text-blue-600\">&nbsp;{user}</span>\r\n        )}\r\n      </h1>\r\n      <p className=\"header-box-subtext\">{subtext}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default HeaderBox;\r\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,YAAY,CAAC,EACjB,OAAO,OAAO,EACd,KAAK,EACL,OAAO,EACP,IAAI,EACW;IACf,qBACE,6PAAC;QAAI,WAAU;;0BACb,6PAAC;gBAAG,WAAU;;oBACX;oBACA,SAAS,4BACR,6PAAC;wBAAK,WAAU;;4BAAgB;4BAAO;;;;;;;;;;;;;0BAG3C,6PAAC;gBAAE,WAAU;0BAAsB;;;;;;;;;;;;AAGzC;uCAEe","debugId":null}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/components/Transactions/Columns.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const columns = registerClientReference(\n    function() { throw new Error(\"Attempted to call columns() from the server but columns is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/sentineltms/frontend/components/Transactions/Columns.tsx <module evaluation>\",\n    \"columns\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,UAAU,IAAA,uRAAuB,EAC1C;IAAa,MAAM,IAAI,MAAM;AAA8N,GAC3P,0FACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 436, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/components/Transactions/Columns.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const columns = registerClientReference(\n    function() { throw new Error(\"Attempted to call columns() from the server but columns is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/sentineltms/frontend/components/Transactions/Columns.tsx\",\n    \"columns\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,UAAU,IAAA,uRAAuB,EAC1C;IAAa,MAAM,IAAI,MAAM;AAA8N,GAC3P,sEACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 458, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/components/Transactions/DataTable.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/sentineltms/frontend/components/Transactions/DataTable.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/sentineltms/frontend/components/Transactions/DataTable.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,uRAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA8T,GAC3V,4FACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 472, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/components/Transactions/DataTable.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/sentineltms/frontend/components/Transactions/DataTable.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/sentineltms/frontend/components/Transactions/DataTable.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,uRAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA0S,GACvU,wEACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 486, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 496, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documents/webite/sentineltms/frontend/app/%28root%29/transactions/page.tsx"],"sourcesContent":["import prisma from \"@/lib/db\";\r\n\r\nimport HeaderBox from \"@/components/HeaderBox\";\r\nimport { columns } from \"@/components/Transactions/Columns\";\r\nimport DataTableDemo from \"@/components/Transactions/DataTable\";\r\n\r\nexport default async function DemoPage() {\r\n  const data = await prisma.transaction.findMany();\r\n\r\n  return (\r\n    <section className=\"home\">\r\n      <div className=\"home-content\">\r\n        <header className=\"home-header\">\r\n          <HeaderBox\r\n            type=\"title\"\r\n            title=\"Transactions\"\r\n            user={\"Analyst\"}\r\n            subtext=\"Access & manage your accounts efficiently\"\r\n          />\r\n        </header>\r\n\r\n        <DataTableDemo columns={columns} data={data} />\r\n      </div>\r\n    </section>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;AACA;AACA;;;;;;;;;;AAEe,eAAe;IAC5B,MAAM,OAAO,MAAM,+IAAM,CAAC,WAAW,CAAC,QAAQ;IAE9C,qBACE,6PAAC;QAAQ,WAAU;kBACjB,cAAA,6PAAC;YAAI,WAAU;;8BACb,6PAAC;oBAAO,WAAU;8BAChB,cAAA,6PAAC,8JAAS;wBACR,MAAK;wBACL,OAAM;wBACN,MAAM;wBACN,SAAQ;;;;;;;;;;;8BAIZ,6PAAC,8KAAa;oBAAC,SAAS,4KAAO;oBAAE,MAAM;;;;;;;;;;;;;;;;;AAI/C","debugId":null}}]
}